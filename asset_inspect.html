<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UCCL Asset Inspection Module</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#333;padding:20px;font-size:16px}
    .container{max-width:1400px;margin:0 auto}
    .header,.card{background:rgba(255,255,255,.95);backdrop-filter:blur(10px);border-radius:15px;padding:30px;margin-bottom:30px;box-shadow:0 10px 30px rgba(0,0,0,.1)}
    .header{text-align:center}
    .header h1{color:#2d3748;font-size:2.5em;font-weight:700;margin-bottom:15px}
    .header p{font-size:1.1em;color:#666}
    .card-title{color:#2d3748;font-size:1.5em;font-weight:700;margin-bottom:25px;padding-bottom:15px;border-bottom:2px solid #e2e8f0}
    .form-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:20px;margin-bottom:20px}
    .form-control{width:100%;padding:14px 18px;border:2px solid #e2e8f0;border-radius:8px;font-size:16px;transition:all .2s ease}
    .form-control:focus{outline:none;border-color:#667eea;box-shadow:0 0 0 3px rgba(102,126,234,.1)}
    .btn{padding:14px 28px;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;transition:all .2s ease;margin:5px}
    .btn:hover{transform:translateY(-1px);box-shadow:0 4px 15px rgba(0,0,0,.2)}
    .btn-primary{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff}
    .btn-success{background:linear-gradient(135deg,#48bb78,#38a169);color:#fff}
    .btn-info{background:linear-gradient(135deg,#4299e1,#3182ce);color:#fff}
    .btn-warning{background:linear-gradient(135deg,#ed8936,#dd6b20);color:#fff}
    .btn-danger{background:linear-gradient(135deg,#f56565,#e53e3e);color:#fff}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .alert{padding:18px;border-radius:8px;margin:18px 0;font-weight:500;font-size:16px}
    .alert-success{background:#c6f6d5;color:#22543d;border-left:4px solid #38a169}
    .alert-error{background:#fed7d7;color:#742a2a;border-left:4px solid #e53e3e}
    .alert-warning{background:#fefcbf;color:#744210;border-left:4px solid #d69e2e}
    .alert-info{background:#ebf8ff;color:#2b6cb0;border-left:4px solid #4299e1}
    .dvir-table{width:100%;border-collapse:collapse;margin-top:25px;background:#fff;border-radius:8px;overflow:hidden;box-shadow:0 4px 15px rgba(0,0,0,.1)}
    .dvir-table th{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:16px;text-align:left;font-weight:600;font-size:16px}
    .dvir-table td{padding:14px 16px;border-bottom:1px solid #e2e8f0;font-size:15px;vertical-align:top;line-height:1.4}
    .dvir-table tr:hover{background:#f7fafc}
    .dvir-table tr:nth-child(even){background:#f8f9fa}
    .status-safe{background:#c6f6d5;color:#22543d;padding:6px 12px;border-radius:6px;font-weight:600;font-size:14px}
    .status-unsafe{background:#fed7d7;color:#742a2a;padding:6px 12px;border-radius:6px;font-weight:600;font-size:14px}
    .status-unknown{background:#e2e8f0;color:#4a5568;padding:6px 12px;border-radius:6px;font-weight:600;font-size:14px}
    .status-overdue{background:#fefcbf;color:#744210;padding:6px 12px;border-radius:6px;font-weight:600;font-size:14px}
    .muted{color:#718096;font-size:14px}
    .progress-bar{width:100%;background:#e2e8f0;border-radius:4px;overflow:hidden;margin:12px 0}
    .progress-fill{height:24px;background:linear-gradient(90deg,#667eea,#764ba2);transition:width 0.3s ease;display:flex;align-items:center;justify-content:center;color:white;font-size:14px;font-weight:600}
    .real-address{background:#d4edda;color:#155724;padding:8px 12px;border-radius:6px;font-weight:500;border-left:4px solid #28a745;font-size:15px}
    .coord-only{color:#666;font-style:italic;font-size:14px}
    .zone-pill{display:inline-block;background:#e2e8f0;border-radius:999px;padding:3px 8px;margin:2px;font-size:12px;color:#495057}
    .config-section{background:#f8f9fa;padding:20px;border-radius:8px;margin:20px 0}
    .config-section h4{margin-bottom:15px;color:#2d3748}
    .checkbox-group{margin:10px 0}
    .checkbox-group label{display:flex;align-items:center;gap:8px;cursor:pointer}
    .checkbox-group input[type="checkbox"]{width:18px;height:18px}
    .email-options{margin-top:15px;padding:15px;background:#e2e8f0;border-radius:8px}
    .ignition-info{font-size:12px;color:#666;margin-top:4px}
    .zone-stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin:20px 0}
    .zone-stat-card{background:white;padding:15px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1);text-align:center}
    .zone-stat-value{font-size:1.8em;font-weight:700;color:#667eea;margin:5px 0}
    .zone-stat-label{font-size:0.9em;color:#666}
    .zone-section{margin:25px 0;border:2px solid #e2e8f0;border-radius:10px;overflow:hidden}
    .zone-header{background:linear-gradient(135deg,#667eea,#764ba2);color:white;padding:15px;font-size:1.2em;font-weight:600}
    .zone-inspections{padding:0}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>UCCL Asset Inspection Dashboard</h1>
      <p>United Civil Construction Ltd</p>
    </div>

    <div class="card">
      <h3 class="card-title">Authentication</h3>
      <div class="form-row">
        <input id="server" class="form-control" placeholder="Server" value="my.geotab.com" />
        <input id="database" class="form-control" placeholder="Database" value="uccnz" />
      </div>
      <div class="form-row">
        <input id="username" class="form-control" placeholder="Username" value="" />
        <input id="password" class="form-control" type="password" placeholder="Password" value="" />
      </div>
      <button id="authButton" class="btn btn-primary">üîê Authenticate</button>
      <div id="authResult"></div>
    </div>

    <div id="dvirSection" class="card" style="display:none;">
      <h3 class="card-title">üìã Asset Inspection Reports</h3>
      
      <!-- Configuration Section -->
      <div class="config-section">
        <h4>üîß Configuration Options</h4>
        <div class="form-row">
          <div>
            <label for="zoneFilter">Filter by Zone:</label>
            <select id="zoneFilter" class="form-control">
              <option value="">All Zones</option>
              <option value="no-zone">No Zone Assigned</option>
            </select>
          </div>
          <div>
            <label for="alertWindow">Overdue Alert Window (minutes):</label>
            <input id="alertWindow" class="form-control" type="number" value="5" min="1" />
          </div>
          <div>
            <label for="assetType">Asset Type:</label>
            <select id="assetType" class="form-control">
              <option value="all">All Assets</option>
              <option value="heavy">Heavy Equipment Only</option>
            </select>
          </div>
        </div>
        
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="enableOverdueAlerts" checked />
            Enable Overdue Inspection Alerts
          </label>
        </div>
        
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="enableAutoEmail" />
            Auto-Email on Defect Detection (Note: Currently logs to console only - not fully implemented)
          </label>
        </div>

        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="groupByZone" />
            Group Inspections by Zone
          </label>
        </div>
        
        <div id="emailOptions" class="email-options" style="display:none;">
          <div class="form-row">
            <input id="emailRecipient" class="form-control" placeholder="Email Recipient" />
            <input id="emailSubject" class="form-control" placeholder="Email Subject" value="Asset Inspection Defect Alert" />
          </div>
          <div>
            <textarea id="emailTemplate" class="form-control" placeholder="Email Template" rows="3">A defect has been detected during asset inspection. Please review the details in the attached report.</textarea>
          </div>
        </div>
      </div>
      
      <div id="infoBanner" class="alert alert-info" style="display:none;"></div>
      <div id="progressContainer" style="display:none;">
        <div class="progress-bar">
          <div id="progressBar" class="progress-fill" style="width:0%;">0%</div>
        </div>
        <div id="progressText" class="muted" style="text-align:center;margin-top:8px;"></div>
      </div>
      <div class="form-row">
        <div>
          <label for="fromDate">From Date:</label>
          <input id="fromDate" class="form-control" type="date" />
        </div>
        <div>
          <label for="fromTime">From Time:</label>
          <input id="fromTime" class="form-control" type="time" value="00:00" />
        </div>
        <div>
          <label for="toDate">To Date:</label>
          <input id="toDate" class="form-control" type="date" />
        </div>
        <div>
          <label for="toTime">To Time:</label>
          <input id="toTime" class="form-control" type="time" value="23:59" />
        </div>
      </div>
      <div style="margin-bottom:20px;">
        <label style="display:block;margin-bottom:8px;font-weight:600;color:#2d3748;">Quick Date Selection:</label>
        <button id="quickToday" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">Today</button>
        <button id="quickYesterday" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">Yesterday</button>
        <button id="quickLast7" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">Last 7 Days</button>
        <button id="quickLast30" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">Last 30 Days</button>
        <button id="quickThisWeek" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">This Week</button>
        <button id="quickThisMonth" class="btn" style="background:#667eea;color:white;padding:8px 16px;font-size:14px;">This Month</button>
      </div>
      <div>
        <button id="getDvir" class="btn btn-success">üìã Retrieve Asset Inspection Sheets</button>
        <button id="downloadCsv" class="btn btn-info" disabled>üìä Download Excel</button>
        <button id="downloadReport" class="btn btn-warning" disabled>üìÑ Download Asset Inspection Report Details</button>
        <button id="logout" class="btn btn-danger">üö™ Logout</button>
      </div>
      
      <!-- Zone Statistics -->
      <div id="zoneStatistics" style="display:none;"></div>
      
      <div id="dvirResult"></div>
    </div>
  </div>

<script>
let credentials = null;
let serverUsed = null;
let mappedDvirData = [];
let ignitionData = {};
let geotabZones = []; // Store zone definitions with boundaries

// Predefined zone list from Advanced_Zone_List spreadsheet
const PREDEFINED_ZONES = [
  "Channel Infrastructure",
  "Donald Road",
  "Gillingham Road",
  "Kaikohe",
  "Kaikohe Work Area",
  "Kaitaia Wastewater",
  "Kiwirail",
  "Mangawhai",
  "Matauri Bay",
  "Maungaturoto Solar Farm",
  "Ngawha",
  "Northpower Dargaville",
  "Port Road Site Office",
  "Rocket Lab",
  "Ruakaka BESS",
  "Ruakaka Solar Farm Site 1",
  "Ruakaka Solar Farm Site 2",
  "Ruakaka Solar Farm Site 3",
  "Te Mihi"
];

function setDefaultDates(){
  const today = new Date();
  const lastWeek = new Date(today.getTime() - 7*24*60*60*1000);
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromDate').value = lastWeek.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
}
setDefaultDates();

// Quick date selection handlers
document.getElementById('quickToday')?.addEventListener('click', function() {
  const today = new Date();
  document.getElementById('fromDate').value = today.toISOString().split('T')[0];
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

document.getElementById('quickYesterday')?.addEventListener('click', function() {
  const yesterday = new Date(Date.now() - 24*60*60*1000);
  document.getElementById('fromDate').value = yesterday.toISOString().split('T')[0];
  document.getElementById('toDate').value = yesterday.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

document.getElementById('quickLast7')?.addEventListener('click', function() {
  const today = new Date();
  const last7 = new Date(Date.now() - 7*24*60*60*1000);
  document.getElementById('fromDate').value = last7.toISOString().split('T')[0];
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

document.getElementById('quickLast30')?.addEventListener('click', function() {
  const today = new Date();
  const last30 = new Date(Date.now() - 30*24*60*60*1000);
  document.getElementById('fromDate').value = last30.toISOString().split('T')[0];
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

document.getElementById('quickThisWeek')?.addEventListener('click', function() {
  const today = new Date();
  const dayOfWeek = today.getDay();
  const monday = new Date(today.getTime() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1) * 24*60*60*1000);
  document.getElementById('fromDate').value = monday.toISOString().split('T')[0];
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

document.getElementById('quickThisMonth')?.addEventListener('click', function() {
  const today = new Date();
  const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
  document.getElementById('fromDate').value = firstDay.toISOString().split('T')[0];
  document.getElementById('toDate').value = today.toISOString().split('T')[0];
  document.getElementById('fromTime').value = '00:00';
  document.getElementById('toTime').value = '23:59';
});

function showMessage(elId, msg, type='info'){
  const el = document.getElementById(elId);
  const c = type==='error'?'alert-error':type==='success'?'alert-success':type==='warning'?'alert-warning':'alert-info';
  el.style.display = '';
  el.innerHTML = `<div class="alert ${c}">${msg}</div>`;
}

function updateProgress(current, total, text = '') {
  const container = document.getElementById('progressContainer');
  const bar = document.getElementById('progressBar');
  const textEl = document.getElementById('progressText');
  
  if (total === 0) {
    container.style.display = 'none';
    return;
  }
  
  container.style.display = 'block';
  const percentage = Math.round((current / total) * 100);
  bar.style.width = `${percentage}%`;
  bar.textContent = `${percentage}%`;
  textEl.textContent = text || `Processing ${current} of ${total} locations...`;
}

async function callGeotabAPI(method, params={}){
  if (window.geotab && typeof window.geotab.call === 'function'){
    return new Promise((resolve,reject)=>window.geotab.call(method, params, resolve, reject));
  }
  if (window.api && typeof window.api.call === 'function'){
    return new Promise((resolve,reject)=>window.api.call(method, params, resolve, reject));
  }
  const requestBody = { method, params: credentials ? {...params, credentials} : params };
  const res = await fetch(`https://${serverUsed}/apiv1`, {
    method:'POST', headers:{'Content-Type':'application/json','Accept':'application/json'}, body: JSON.stringify(requestBody)
  });
  if(!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
  const data = await res.json();
  if(data.error) throw new Error(data.error.message || data.error.name);
  return data.result;
}

function extractId(data){
  if(!data) return null;
  if(typeof data==='object' && data.id) return data.id;
  if(typeof data==='string'){ try{ return JSON.parse(data).id || null }catch(e){ return data } }
  return null;
}

function extractLocation(loc){
  if(!loc) return {latitude:null, longitude:null};
  if(typeof loc==='object'){
    if(loc.location && loc.location.x && loc.location.y) return {latitude:loc.location.y, longitude:loc.location.x};
    if(loc.x && loc.y) return {latitude:loc.y, longitude:loc.x};
  }
  if(typeof loc==='string'){
    try{
      const p = JSON.parse(loc);
      if(p.location && p.location.x && p.location.y) return {latitude:p.location.y, longitude:p.location.x};
      if(p.x && p.y) return {latitude:p.y, longitude:p.x};
    }catch(e){}
  }
  return {latitude:null, longitude:null};
}

// Point-in-polygon algorithm (ray casting method)
function isPointInPolygon(point, polygon) {
  if (!polygon || polygon.length < 3) return false;
  
  const x = point.longitude;
  const y = point.latitude;
  let inside = false;
  
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    
    const intersect = ((yi > y) !== (yj > y))
        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  
  return inside;
}

// Fetch zone definitions from Geotab
async function fetchGeotabZones() {
  try {
    showMessage('infoBanner', 'üìç Fetching zone definitions from Geotab...', 'info');
    
    const zones = await callGeotabAPI('Get', {
      typeName: 'Zone',
      resultsLimit: 5000
    });
    
    if (zones && zones.length > 0) {
      // Filter to only include zones from our predefined list
      geotabZones = zones.filter(zone => {
        const zoneName = zone.name || zone.Name || '';
        return PREDEFINED_ZONES.includes(zoneName);
      }).map(zone => ({
        id: zone.id,
        name: zone.name || zone.Name,
        points: zone.points || zone.Points || [],
        // Convert points to usable format
        polygon: (zone.points || zone.Points || []).map(p => ({
          x: p.x || p.X || 0,
          y: p.y || p.Y || 0
        }))
      }));
      
      console.log(`Loaded ${geotabZones.length} zone definitions from Geotab:`, geotabZones.map(z => z.name));
      return geotabZones;
    }
  } catch (error) {
    console.error('Error fetching zones from Geotab:', error);
    showMessage('infoBanner', '‚ö†Ô∏è Could not fetch zone definitions. Zones may not be assigned correctly.', 'warning');
  }
  
  return [];
}

// Match inspection coordinates to zones
function matchCoordinatesToZones(latitude, longitude) {
  if (!latitude || !longitude || !geotabZones.length) {
    return [];
  }
  
  const matchedZones = [];
  const point = { latitude, longitude };
  
  for (const zone of geotabZones) {
    if (zone.polygon && zone.polygon.length >= 3) {
      if (isPointInPolygon(point, zone.polygon)) {
        matchedZones.push(zone.name);
      }
    }
  }
  
  return matchedZones;
}

// Use Geotab's GetAddresses method
async function getGeotabAddresses(coordinates) {
  if (!coordinates.length) return [];
  
  // Convert to Geotab format: {x: lon, y: lat}
  const geotabCoords = coordinates.map(c => ({ x: Number(c.lon), y: Number(c.lat) }));
  
  try {
    const results = await callGeotabAPI('GetAddresses', { coordinates: geotabCoords });
    
    // Map results to extract formatted addresses and zones
    return results.map(r => ({
      formattedAddress: (r && (r.formattedAddress || r.FormattedAddress)) || '',
      city: r && (r.city || r.City),
      country: r && (r.country || r.Country),
      postalCode: r && (r.postalCode || r.PostalCode),
      street: r && (r.street || r.Street),
      streetName: r && (r.streetName || r.StreetName),
      streetNumber: r && (r.streetNumber || r.StreetNumber),
      zones: (r && (r.zones || r.Zones) || []).map(z => (z && (z.name || z.Name)) || '').filter(Boolean)
    }));
  } catch (error) {
    console.log('GetAddresses API error:', error);
    return coordinates.map(() => ({ formattedAddress: '', zones: [] }));
  }
}

async function resolveAllAddresses(rows) {
  const points = [];
  rows.forEach((r, idx) => {
    if (r.latitude != null && r.longitude != null) {
      points.push({ lat: r.latitude, lon: r.longitude, idx });
    }
  });
  
  if (!points.length) {
    return;
  }
  
  const BATCH_SIZE = 50;
  
  for (let start = 0; start < points.length; start += BATCH_SIZE) {
    const chunk = points.slice(start, start + BATCH_SIZE);
    const progress = Math.min(start + BATCH_SIZE, points.length);
    
    updateProgress(start, points.length, `Resolving addresses ${progress}/${points.length}...`);
    
    try {
      const addresses = await getGeotabAddresses(chunk);
      
      // Apply addresses to rows
      addresses.forEach((addr, i) => {
        const rowIndex = chunk[i].idx;
        const row = rows[rowIndex];
        
        if (addr.formattedAddress && addr.formattedAddress.trim()) {
          row.resolvedAddress = addr.formattedAddress.trim();
        }
        
        // Try to get zones from API first
        let zones = addr.zones || [];
        
        // If no zones from API, try matching by coordinates
        if (zones.length === 0 && geotabZones.length > 0) {
          zones = matchCoordinatesToZones(row.latitude, row.longitude);
          if (zones.length > 0) {
            console.log(`Matched coordinates (${row.latitude}, ${row.longitude}) to zones:`, zones);
          }
        }
        
        row.zones = zones;
      });
      
      // Re-render table with current progress
      const selectedZone = document.getElementById('zoneFilter').value;
      const filteredData = filterDataByZone(rows, selectedZone);
      renderTable(filteredData);
      
    } catch (error) {
      // Continue processing other batches
      console.error('Error in address resolution batch:', error);
    }
    
    // Small delay between batches
    if (start + BATCH_SIZE < points.length) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }
  
  updateProgress(points.length, points.length, 'Complete!');
}

// Get ignition data for devices
async function getIgnitionData(fromDate, toDate) {
  try {
    showMessage('infoBanner', 'üîç Retrieving ignition data for overdue calculations...', 'info');
    
    const statusData = await callGeotabAPI('Get', {
      typeName: 'StatusData',
      search: {
        fromDate: fromDate + 'T00:00:00.000Z',
        toDate: toDate + 'T23:59:59.999Z',
        diagnosticSearch: {
          id: 'DiagnosticIgnitionId'
        }
      }
    });
    
    // Process ignition data
    ignitionData = {};
    
    statusData.forEach(status => {
      if (status.device && status.data && status.datetime) {
        const deviceId = extractId(status.device);
        if (!ignitionData[deviceId]) {
          ignitionData[deviceId] = [];
        }
        
        ignitionData[deviceId].push({
          timestamp: new Date(status.datetime),
          isIgnitionOn: status.data > 0
        });
      }
    });
    
    // Sort ignition events by timestamp for each device
    Object.keys(ignitionData).forEach(deviceId => {
      ignitionData[deviceId].sort((a, b) => a.timestamp - b.timestamp);
    });
    
    return ignitionData;
    
  } catch (error) {
    console.error('Error getting ignition data:', error);
    showMessage('infoBanner', '‚ö†Ô∏è Could not retrieve ignition data for overdue calculations', 'warning');
    return {};
  }
}

// Find the most relevant ignition time for a DVIR
function findRelevantIgnitionTime(deviceId, inspectionTime) {
  if (!ignitionData[deviceId] || ignitionData[deviceId].length === 0) {
    return null;
  }
  
  const deviceIgnitions = ignitionData[deviceId];
  let relevantIgnitionTime = null;
  
  // Find the last ignition ON event before the inspection
  for (let i = deviceIgnitions.length - 1; i >= 0; i--) {
    const ignitionEvent = deviceIgnitions[i];
    
    if (ignitionEvent.timestamp <= inspectionTime && ignitionEvent.isIgnitionOn) {
      let sessionStart = ignitionEvent.timestamp;
      
      // Look backwards to find when this ignition session started
      for (let j = i - 1; j >= 0; j--) {
        const prevEvent = deviceIgnitions[j];
        if (!prevEvent.isIgnitionOn || (sessionStart - prevEvent.timestamp) > 30 * 60 * 1000) {
          break;
        }
        sessionStart = prevEvent.timestamp;
      }
      
      relevantIgnitionTime = sessionStart;
      break;
    }
  }
  
  return relevantIgnitionTime;
}

// Check for overdue inspections using proper ignition time comparison
function checkOverdueInspections(rows) {
  const alertWindow = parseInt(document.getElementById('alertWindow').value) || 5;
  const assetType = document.getElementById('assetType').value;
  const enableAlerts = document.getElementById('enableOverdueAlerts').checked;
  
  if (!enableAlerts) {
    return rows.map(row => {
      row.isOverdue = false;
      row.ignitionTime = null;
      row.timeToInspection = null;
      return row;
    });
  }
  
  const now = new Date();
  
  return rows.map(row => {
    const isHeavyEquipment = row.vehicleName && (
      row.vehicleName.toLowerCase().includes('excavator') ||
      row.vehicleName.toLowerCase().includes('loader') ||
      row.vehicleName.toLowerCase().includes('dozer') ||
      row.vehicleName.toLowerCase().includes('crane') ||
      row.vehicleName.toLowerCase().includes('grader') ||
      row.vehicleName.toLowerCase().includes('compactor') ||
      row.vehicleName.toLowerCase().includes('roller') ||
      row.vehicleName.toLowerCase().includes('backhoe')
    );
    
    if (assetType === 'heavy' && !isHeavyEquipment) {
      row.isOverdue = false;
      row.ignitionTime = null;
      row.timeToInspection = null;
      return row;
    }
    
    const inspectionTime = new Date(row.dateTime);
    const deviceId = row.deviceId;
    
    row.isOverdue = false;
    row.ignitionTime = null;
    row.timeToInspection = null;
    
    const ignitionTime = findRelevantIgnitionTime(deviceId, inspectionTime);
    
    if (ignitionTime) {
      row.ignitionTime = ignitionTime;
      const timeDiff = (inspectionTime - ignitionTime) / (1000 * 60);
      row.timeToInspection = Math.round(timeDiff);
      
      if (row.isInspectedByDriver && timeDiff > alertWindow) {
        row.isOverdue = true;
      } else if (!row.isInspectedByDriver) {
        const timeSinceIgnition = (now - ignitionTime) / (1000 * 60);
        if (timeSinceIgnition > alertWindow) {
          row.isOverdue = true;
        }
      }
    }
    
    return row;
  });
}

// Generate zone statistics
function generateZoneStatistics(rows) {
  const zoneStats = {};
  let totalInspections = 0;
  let totalWithDefects = 0;
  let totalOverdue = 0;
  
  rows.forEach(row => {
    const zones = row.zones && row.zones.length > 0 ? row.zones : ['no-zone'];
    
    zones.forEach(zone => {
      if (!zoneStats[zone]) {
        zoneStats[zone] = {
          inspections: 0,
          withDefects: 0,
          overdue: 0,
          safe: 0,
          unsafe: 0
        };
      }
      
      zoneStats[zone].inspections++;
      totalInspections++;
      
      if (row.defects && row.defects !== '[]' && row.defects !== '') {
        zoneStats[zone].withDefects++;
        totalWithDefects++;
      }
      
      if (row.isOverdue) {
        zoneStats[zone].overdue++;
        totalOverdue++;
      }
      
      if (row.isSafeToOperate === true) {
        zoneStats[zone].safe++;
      } else if (row.isSafeToOperate === false) {
        zoneStats[zone].unsafe++;
      }
    });
  });
  
  return { zoneStats, totalInspections, totalWithDefects, totalOverdue };
}

// Render zone statistics
function renderZoneStatistics(rows) {
  const stats = generateZoneStatistics(rows);
  const statsDiv = document.getElementById('zoneStatistics');
  
  let html = `<h3 class="card-title">üìä Zone Statistics</h3>`;
  
  // Overall statistics
  html += `<div class="zone-stats">
    <div class="zone-stat-card">
      <div class="zone-stat-value">${stats.totalInspections}</div>
      <div class="zone-stat-label">Total Inspections</div>
    </div>
    <div class="zone-stat-card">
      <div class="zone-stat-value">${stats.totalWithDefects}</div>
      <div class="zone-stat-label">With Defects</div>
    </div>
    <div class="zone-stat-card">
      <div class="zone-stat-value">${stats.totalOverdue}</div>
      <div class="zone-stat-label">Overdue</div>
    </div>
  </div>`;
  
  // Per-zone statistics
  const sortedZones = Object.keys(stats.zoneStats).sort((a, b) => 
    stats.zoneStats[b].inspections - stats.zoneStats[a].inspections
  );
  
  if (sortedZones.length > 0) {
    html += `<h4 style="margin:20px 0 10px 0;">Per Zone Breakdown</h4>`;
    html += `<div class="zone-stats">`;
    
    sortedZones.forEach(zone => {
      const zoneStat = stats.zoneStats[zone];
      const defectRate = Math.round((zoneStat.withDefects / zoneStat.inspections) * 100);
      const overdueRate = Math.round((zoneStat.overdue / zoneStat.inspections) * 100);
      
      html += `
        <div class="zone-stat-card">
          <div class="zone-stat-label" style="font-weight:600;margin-bottom:8px;">${zone === 'no-zone' ? 'No Zone' : zone}</div>
          <div class="zone-stat-value">${zoneStat.inspections}</div>
          <div class="zone-stat-label">Inspections</div>
          <div style="margin-top:8px;font-size:0.9em;">
            <div>üîß ${zoneStat.withDefects} defects (${defectRate}%)</div>
            <div>‚è∞ ${zoneStat.overdue} overdue (${overdueRate}%)</div>
            <div>‚úÖ ${zoneStat.safe} safe</div>
            <div>‚ùå ${zoneStat.unsafe} unsafe</div>
          </div>
        </div>
      `;
    });
    
    html += `</div>`;
  }
  
  statsDiv.innerHTML = html;
  statsDiv.style.display = 'block';
}

function renderTable(rows){
  const resultDiv = document.getElementById('dvirResult');
  const groupByZone = document.getElementById('groupByZone').checked;
  
  if (groupByZone) {
    renderTableGroupedByZone(rows);
    return;
  }
  
  let html = `<table class="dvir-table"><thead><tr>
    <th>Date/Time</th><th>Driver</th><th>Vehicle</th><th>Status</th><th>Driver Inspected</th>
    <th>Defects</th><th>Location</th><th>Zones</th><th>Odometer</th><th>Engine Hours</th><th>Hubbometer</th><th>Driver Remarks</th>
  </tr></thead><tbody>`;
  
  let overdueCount = 0;
  
  rows.forEach((r, index) => {
    if (r.isOverdue) overdueCount++;

    const status = r.isSafeToOperate===true?'<span class="status-safe">SAFE</span>':
                  r.isSafeToOperate===false?'<span class="status-unsafe">‚ö†Ô∏è UNSAFE</span>':
                  r.isOverdue?'<span class="status-overdue">‚è∞ OVERDUE</span>':
                  '<span class="status-unknown">UNKNOWN</span>';

    let defectDisplay = '<em class="muted">None</em>';
    if (r.defects && r.defects !== '[]' && r.defects !== '') {
      try{
        const d = JSON.parse(r.defects);
        if(Array.isArray(d)&&d.length>0) {
          const defectList = d.map(def => {
            let defectName = '';

            // Check DefectRemarks array for the remark text
            if (def.defectRemarks && Array.isArray(def.defectRemarks) && def.defectRemarks.length > 0) {
              defectName = def.defectRemarks[0].remark || def.defectRemarks[0].Remark || '';
            }

            // Check Defect object for defect name
            if (!defectName && def.defect && typeof def.defect === 'object') {
              defectName = def.defect.name || def.defect.Name || '';
            }

            // Check Part object for part name
            if (!defectName && def.part && typeof def.part === 'object') {
              defectName = def.part.name || def.part.Name || '';
            }

            // Fallback to direct properties
            if (!defectName) {
              defectName = def.name || def.Name || def.remark || def.Remark || 'Defect detected';
            }

            const repairStatus = def.repairStatus || def.RepairStatus || '';
            return `${defectName}${repairStatus ? ' [' + repairStatus + ']' : ''}`;
          }).join(', ');
          defectDisplay = `<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è ${defectList}</span>`;
        }
      }
      catch(e){
        console.error('Error parsing defects:', e, 'Raw defects:', r.defects);
        if(r.defects.length>10) defectDisplay = '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Defects present</span>';
      }
    }

    let locationDisplay = '<em class="muted">No location</em>';
    if (r.latitude && r.longitude) {
      if (r.resolvedAddress && r.resolvedAddress.trim() && r.resolvedAddress.length > 8) {
        locationDisplay = `<div class="real-address">üìç ${r.resolvedAddress}</div>`;
      } else {
        const coords = `${Number(r.latitude).toFixed(6)}, ${Number(r.longitude).toFixed(6)}`;
        locationDisplay = `<span class="coord-only">${coords}</span>`;
      }
    }

    const zonesDisplay = r.zones && r.zones.length > 0
      ? r.zones.map(z => `<span class="zone-pill">${z}</span>`).join('')
      : '<em class="muted">No zone</em>';

    let ignitionInfo = '';
    if (r.ignitionTime) {
      const ignitionStr = new Date(r.ignitionTime).toLocaleString();
      const timeDiff = r.timeToInspection;
      ignitionInfo = `<div class="ignition-info">Ignition: ${ignitionStr} (${timeDiff}min before)</div>`;
    }

    html += `<tr data-inspection-id="${r.id}">
      <td>${r.dateTime}${ignitionInfo}</td>
      <td><strong>${r.driverName}</strong></td>
      <td><strong>${r.vehicleName}</strong></td>
      <td>${status}</td>
      <td>${r.isInspectedByDriver===true?'‚úÖ Yes':'‚ùå No'}</td>
      <td>${defectDisplay}</td>
      <td>${locationDisplay}</td>
      <td>${zonesDisplay}</td>
      <td>${r.odometer?Math.round(r.odometer/1000*100)/100+' km':'N/A'}</td>
      <td>${r.engineHours?Math.round(r.engineHours/3600*100)/100+' hrs':'N/A'}</td>
      <td>${r.hubbometer ? `<strong style="color:#2d5016;">${r.hubbometer}</strong>` : '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Missing</span>'}</td>
      <td>${r.driverRemark || '<em class="muted">No remarks</em>'}</td>
    </tr>`;
  });
  
  if (overdueCount > 0) {
    html = `<div class="alert alert-warning">‚ö†Ô∏è <strong>${overdueCount} overdue inspection(s) detected!</strong> These inspections were completed more than ${document.getElementById('alertWindow').value} minutes after ignition.</div>` + html;
  }
  
  html += `</tbody></table>`;
  resultDiv.innerHTML = html;
}

// Render table grouped by zone
function renderTableGroupedByZone(rows) {
  const resultDiv = document.getElementById('dvirResult');
  
  const rowsByZone = {};
  const noZoneRows = [];
  
  rows.forEach(row => {
    if (row.zones && row.zones.length > 0) {
      row.zones.forEach(zone => {
        if (!rowsByZone[zone]) {
          rowsByZone[zone] = [];
        }
        rowsByZone[zone].push(row);
      });
    } else {
      noZoneRows.push(row);
    }
  });
  
  let html = '';
  
  Object.keys(rowsByZone).sort().forEach(zone => {
    const zoneRows = rowsByZone[zone];
    
    html += `<div class="zone-section">
      <div class="zone-header">üìç ${zone} (${zoneRows.length} inspections)</div>
      <div class="zone-inspections">
        <table class="dvir-table">
          <thead><tr>
            <th>Date/Time</th><th>Driver</th><th>Vehicle</th><th>Status</th><th>Driver Inspected</th>
            <th>Defects</th><th>Location</th><th>Odometer</th><th>Engine Hours</th><th>Hubbometer</th><th>Driver Remarks</th>
          </tr></thead>
          <tbody>`;
    
    zoneRows.forEach(r => {
      const status = r.isSafeToOperate===true?'<span class="status-safe">SAFE</span>':
                    r.isSafeToOperate===false?'<span class="status-unsafe">‚ö†Ô∏è UNSAFE</span>':
                    r.isOverdue?'<span class="status-overdue">‚è∞ OVERDUE</span>':
                    '<span class="status-unknown">UNKNOWN</span>';

      let defectDisplay = '<em class="muted">None</em>';
      if (r.defects && r.defects !== '[]' && r.defects !== '') {
        try{
          const d = JSON.parse(r.defects);
          if(Array.isArray(d)&&d.length>0) {
            const defectList = d.map(def => {
              let defectName = '';
              // Check DefectRemarks array
              if (def.defectRemarks && Array.isArray(def.defectRemarks) && def.defectRemarks.length > 0) {
                defectName = def.defectRemarks[0].remark || def.defectRemarks[0].Remark || '';
              }
              // Check Defect object
              if (!defectName && def.defect && typeof def.defect === 'object') {
                defectName = def.defect.name || def.defect.Name || '';
              }
              // Check Part object
              if (!defectName && def.part && typeof def.part === 'object') {
                defectName = def.part.name || def.part.Name || '';
              }
              // Fallback
              if (!defectName) {
                defectName = def.name || def.Name || def.remark || def.Remark || 'Defect detected';
              }
              const repairStatus = def.repairStatus || def.RepairStatus || '';
              return `${defectName}${repairStatus ? ' [' + repairStatus + ']' : ''}`;
            }).join(', ');
            defectDisplay = `<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è ${defectList}</span>`;
          }
        }
        catch(e){
          console.error('Error parsing defects:', e, 'Raw defects:', r.defects);
          if(r.defects.length>10) defectDisplay = '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Defects present</span>';
        }
      }

      let locationDisplay = '<em class="muted">No location</em>';
      if (r.latitude && r.longitude) {
        if (r.resolvedAddress && r.resolvedAddress.trim() && r.resolvedAddress.length > 8) {
          locationDisplay = `<div class="real-address">üìç ${r.resolvedAddress}</div>`;
        } else {
          const coords = `${Number(r.latitude).toFixed(6)}, ${Number(r.longitude).toFixed(6)}`;
          locationDisplay = `<span class="coord-only">${coords}</span>`;
        }
      }

      let ignitionInfo = '';
      if (r.ignitionTime) {
        const ignitionStr = new Date(r.ignitionTime).toLocaleString();
        const timeDiff = r.timeToInspection;
        ignitionInfo = `<div class="ignition-info">Ignition: ${ignitionStr} (${timeDiff}min before)</div>`;
      }

      html += `<tr data-inspection-id="${r.id}">
        <td>${r.dateTime}${ignitionInfo}</td>
        <td><strong>${r.driverName}</strong></td>
        <td><strong>${r.vehicleName}</strong></td>
        <td>${status}</td>
        <td>${r.isInspectedByDriver===true?'‚úÖ Yes':'‚ùå No'}</td>
        <td>${defectDisplay}</td>
        <td>${locationDisplay}</td>
        <td>${r.odometer?Math.round(r.odometer/1000*100)/100+' km':'N/A'}</td>
        <td>${r.engineHours?Math.round(r.engineHours/3600*100)/100+' hrs':'N/A'}</td>
        <td>${r.hubbometer ? `<strong style="color:#2d5016;">${r.hubbometer}</strong>` : '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Missing</span>'}</td>
        <td>${r.driverRemark || '<em class="muted">No remarks</em>'}</td>
      </tr>`;
    });
    
    html += `</tbody></table></div></div>`;
  });
  
  if (noZoneRows.length > 0) {
    html += `<div class="zone-section">
      <div class="zone-header">‚ùì No Zone Assigned (${noZoneRows.length} inspections)</div>
      <div class="zone-inspections">
        <table class="dvir-table">
          <thead><tr>
            <th>Date/Time</th><th>Driver</th><th>Vehicle</th><th>Status</th><th>Driver Inspected</th>
            <th>Defects</th><th>Location</th><th>Odometer</th><th>Engine Hours</th><th>Hubbometer</th><th>Driver Remarks</th>
          </tr></thead>
          <tbody>`;
    
    noZoneRows.forEach(r => {
      const status = r.isSafeToOperate===true?'<span class="status-safe">SAFE</span>':
                    r.isSafeToOperate===false?'<span class="status-unsafe">‚ö†Ô∏è UNSAFE</span>':
                    r.isOverdue?'<span class="status-overdue">‚è∞ OVERDUE</span>':
                    '<span class="status-unknown">UNKNOWN</span>';

      let defectDisplay = '<em class="muted">None</em>';
      if (r.defects && r.defects !== '[]' && r.defects !== '') {
        try{
          const d = JSON.parse(r.defects);
          if(Array.isArray(d)&&d.length>0) {
            const defectList = d.map(def => {
              let defectName = '';
              // Check DefectRemarks array
              if (def.defectRemarks && Array.isArray(def.defectRemarks) && def.defectRemarks.length > 0) {
                defectName = def.defectRemarks[0].remark || def.defectRemarks[0].Remark || '';
              }
              // Check Defect object
              if (!defectName && def.defect && typeof def.defect === 'object') {
                defectName = def.defect.name || def.defect.Name || '';
              }
              // Check Part object
              if (!defectName && def.part && typeof def.part === 'object') {
                defectName = def.part.name || def.part.Name || '';
              }
              // Fallback
              if (!defectName) {
                defectName = def.name || def.Name || def.remark || def.Remark || 'Defect detected';
              }
              const repairStatus = def.repairStatus || def.RepairStatus || '';
              return `${defectName}${repairStatus ? ' [' + repairStatus + ']' : ''}`;
            }).join(', ');
            defectDisplay = `<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è ${defectList}</span>`;
          }
        }
        catch(e){
          console.error('Error parsing defects:', e, 'Raw defects:', r.defects);
          if(r.defects.length>10) defectDisplay = '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Defects present</span>';
        }
      }

      let locationDisplay = '<em class="muted">No location</em>';
      if (r.latitude && r.longitude) {
        if (r.resolvedAddress && r.resolvedAddress.trim() && r.resolvedAddress.length > 8) {
          locationDisplay = `<div class="real-address">üìç ${r.resolvedAddress}</div>`;
        } else {
          const coords = `${Number(r.latitude).toFixed(6)}, ${Number(r.longitude).toFixed(6)}`;
          locationDisplay = `<span class="coord-only">${coords}</span>`;
        }
      }

      let ignitionInfo = '';
      if (r.ignitionTime) {
        const ignitionStr = new Date(r.ignitionTime).toLocaleString();
        const timeDiff = r.timeToInspection;
        ignitionInfo = `<div class="ignition-info">Ignition: ${ignitionStr} (${timeDiff}min before)</div>`;
      }

      html += `<tr data-inspection-id="${r.id}">
        <td>${r.dateTime}${ignitionInfo}</td>
        <td><strong>${r.driverName}</strong></td>
        <td><strong>${r.vehicleName}</strong></td>
        <td>${status}</td>
        <td>${r.isInspectedByDriver===true?'‚úÖ Yes':'‚ùå No'}</td>
        <td>${defectDisplay}</td>
        <td>${locationDisplay}</td>
        <td>${r.odometer?Math.round(r.odometer/1000*100)/100+' km':'N/A'}</td>
        <td>${r.engineHours?Math.round(r.engineHours/3600*100)/100+' hrs':'N/A'}</td>
        <td>${r.hubbometer ? `<strong style="color:#2d5016;">${r.hubbometer}</strong>` : '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Missing</span>'}</td>
        <td>${r.driverRemark || '<em class="muted">No remarks</em>'}</td>
      </tr>`;
    });
    
    html += `</tbody></table></div></div>`;
  }
  
  resultDiv.innerHTML = html;
}

// Send email for defects
async function sendDefectEmail(defectRow) {
  const enableAutoEmail = document.getElementById('enableAutoEmail').checked;
  if (!enableAutoEmail) return;
  
  const recipient = document.getElementById('emailRecipient').value;
  const subject = document.getElementById('emailSubject').value;
  const template = document.getElementById('emailTemplate').value;
  
  if (!recipient) {
    showMessage('infoBanner', 'Email recipient is required for auto-email feature', 'warning');
    return;
  }
  
  try {
    const emailBody = `${template}\n\nAsset: ${defectRow.vehicleName}\nDriver: ${defectRow.driverName}\nDate/Time: ${defectRow.dateTime}\nDefects: ${defectRow.defects}`;
    
    console.log(`Would send email to: ${recipient}`);
    console.log(`Subject: ${subject}`);
    console.log(`Body: ${emailBody}`);
    
    showMessage('infoBanner', `Defect email would be sent to ${recipient}`, 'success');
  } catch (error) {
    showMessage('infoBanner', `Failed to send email: ${error.message}`, 'error');
  }
}

// Update zone dropdown with predefined zones from spreadsheet
function updateZoneDropdown() {
  const zoneFilter = document.getElementById('zoneFilter');
  
  // Clear existing options except "All Zones" and "No Zone Assigned"
  zoneFilter.innerHTML = '<option value="">All Zones</option><option value="no-zone">No Zone Assigned</option>';
  
  // Add predefined zones from the spreadsheet
  PREDEFINED_ZONES.forEach(zone => {
    const option = document.createElement('option');
    option.value = zone;
    option.textContent = zone;
    zoneFilter.appendChild(option);
  });
  
  console.log('Updated zone dropdown with predefined zones:', PREDEFINED_ZONES);
}

// Filter data by selected zone
function filterDataByZone(data, selectedZone) {
  if (!selectedZone || selectedZone === '') {
    return data;
  }
  
  if (selectedZone === 'no-zone') {
    // Return rows with no zones or empty zones array
    return data.filter(row => !row.zones || row.zones.length === 0);
  }
  
  // Return rows that have the selected zone in their zones array
  return data.filter(row => {
    return row.zones && Array.isArray(row.zones) && row.zones.includes(selectedZone);
  });
}

document.getElementById('authButton').onclick = async function(){
  const server = document.getElementById('server').value.trim();
  const database = document.getElementById('database').value.trim();
  const username = document.getElementById('username').value.trim();
  const password = document.getElementById('password').value;
  if(!server || !database || !username || !password){ showMessage('authResult','Please fill in all fields','error'); return; }
  try{
    showMessage('authResult','Authenticating...','warning');
    serverUsed = server;
    const res = await callGeotabAPI('Authenticate', { userName:username, password, database });
    if(res.path && res.path !== 'ThisServer'){
      serverUsed = res.path;
      const res2 = await callGeotabAPI('Authenticate', { userName:username, password, database });
      credentials = res2.credentials;
    } else {
      credentials = res.credentials;
    }
    showMessage('authResult','Authentication successful!','success');
    document.getElementById('dvirSection').style.display = '';
    // Initialize zone dropdown with predefined zones after authentication
    updateZoneDropdown();
    // Fetch zone definitions from Geotab for coordinate matching
    await fetchGeotabZones();
  }catch(e){
    showMessage('authResult',`Authentication failed: ${e.message}`,'error');
  }
};

document.getElementById('getDvir').onclick = async function(){
  if(!credentials && !window.geotab && !window.api){ showMessage('infoBanner','Not authenticated','error'); return; }
  
  const fromDate = document.getElementById('fromDate').value;
  const toDate = document.getElementById('toDate').value;
  const fromTime = document.getElementById('fromTime').value || '00:00';
  const toTime = document.getElementById('toTime').value || '23:59';
  
  if(!fromDate || !toDate){ showMessage('infoBanner','Please select both from and to dates','error'); return; }

  // Construct datetime strings with time
  const fromDateTime = `${fromDate}T${fromTime}:00.000Z`;
  const toDateTime = `${toDate}T${toTime}:59.999Z`;

  showMessage('infoBanner','Getting Asset Inspection logs...','warning');
  document.getElementById('downloadCsv').disabled = true;
  document.getElementById('downloadReport').disabled = true;

  try{
    // Fetch zone definitions if not already loaded
    if (geotabZones.length === 0) {
      await fetchGeotabZones();
    }
    
    await getIgnitionData(fromDate, toDate);
    
    const dvirLogs = await callGeotabAPI('Get', {
      typeName:'DVIRLog',
      search:{ fromDate: fromDateTime, toDate: toDateTime }
    });

    if(!dvirLogs || dvirLogs.length===0){
      showMessage('infoBanner','No DVIR logs for the selected range','warning');
      document.getElementById('dvirResult').innerHTML='';
      return;
    }

    console.log('=== DVIRLog RESPONSE INSPECTION ===');
    console.log(`Total DVIRLog records fetched: ${dvirLogs.length}`);
    if (dvirLogs.length > 0) {
      const sampleLog = dvirLogs[0];
      console.log('Sample DVIRLog properties:', Object.keys(sampleLog).join(', '));
      console.log('Sample DVIRLog.dVIRDefects:', sampleLog.dVIRDefects);
    }

    // Map defects from dVIRDefects property (the actual defect objects)
    let defectMap = {};
    let totalDefects = 0;

    dvirLogs.forEach(log => {
      // Use dVIRDefects property which contains the actual defect objects
      if (log.dVIRDefects && Array.isArray(log.dVIRDefects) && log.dVIRDefects.length > 0) {
        defectMap[log.id] = log.dVIRDefects;
        totalDefects += log.dVIRDefects.length;
      }
    });

    const logsWithDefects = Object.keys(defectMap).length;

    console.log('=== DEFECT MAPPING COMPLETE ===');
    console.log(`Logs with defects: ${logsWithDefects}`);
    console.log(`Total defects: ${totalDefects}`);

    if (totalDefects > 0) {
      const firstDefect = Object.values(defectMap)[0][0];
      console.log('Sample defect structure:', firstDefect);
      console.log('Defect properties:', Object.keys(firstDefect).join(', '));
    }

    if (logsWithDefects > 0) {
      showMessage('infoBanner', `‚úÖ Loaded ${totalDefects} defect records from ${logsWithDefects} inspections`, 'success');
    } else {
      showMessage('infoBanner', `‚úÖ No defects found in this date range`, 'success');
    }

    // Fetch custom data to get Hubbometer field values
    let customDataMap = {};
    try {
      showMessage('infoBanner', 'üìã Fetching custom field data (Hubbometer)...', 'info');
      
      const customData = await callGeotabAPI('Get', {
        typeName: 'CustomData',
        search: {
          fromDate: fromDateTime,
          toDate: toDateTime
        }
      });
      
      // Map custom data by device and datetime for quick lookup
      customData.forEach(cd => {
        if (cd.data && cd.device && cd.dateTime) {
          const deviceId = extractId(cd.device);
          const dateTime = new Date(cd.dateTime).getTime();
          const key = `${deviceId}_${dateTime}`;
          
          // Parse the custom data to find Hubbometer field
          try {
            const data = typeof cd.data === 'string' ? JSON.parse(cd.data) : cd.data;
            // Look for "Hubbometer" field
            if (data['Hubbometer'] || data['hubbometer']) {
              customDataMap[key] = data['Hubbometer'] || data['hubbometer'];
            }
          } catch (e) {
            // If data is already the value
            if (cd.data) {
              customDataMap[key] = cd.data;
            }
          }
        }
      });
      
      console.log(`Found ${Object.keys(customDataMap).length} custom Hubbometer entries`);
    } catch (error) {
      console.log('Could not fetch custom data:', error);
      showMessage('infoBanner', '‚ö†Ô∏è Could not fetch custom Hubbometer data, will try other methods', 'warning');
    }

    const driverIds = new Set(), deviceIds = new Set();
    dvirLogs.forEach(l=>{ const did = extractId(l.driver); const vid = extractId(l.device); if(did) driverIds.add(did); if(vid) deviceIds.add(vid); });
    const calls = [];
    Array.from(driverIds).forEach(id=>calls.push({method:'Get', params:{typeName:'User', search:{id}}}));
    Array.from(deviceIds).forEach(id=>calls.push({method:'Get', params:{typeName:'Device', search:{id}}}));
    const lookup = await callGeotabAPI('ExecuteMultiCall', { calls });
    const driverNames = {}; const deviceNames={}; let idx=0;
    Array.from(driverIds).forEach(id=>{ const r=lookup[idx++]; driverNames[id]=(r && r[0] && (r[0].name || `${r[0].firstName||''} ${r[0].lastName||''}`.trim())) || `Driver ${id}`; });
    Array.from(deviceIds).forEach(id=>{ const r=lookup[idx++]; deviceNames[id]=(r && r[0] && r[0].name) || `Device ${id}`; });

    mappedDvirData = dvirLogs.map(l=>{
      const driverId = extractId(l.driver);
      const deviceId = extractId(l.device);
      const loc = extractLocation(l.location);
      
      // Extract hubbometer - try multiple sources in priority order
      let hubbometerValue = '';
      
      // 1. Check custom data map for "Hubbometer" field
      const inspectionTime = new Date(l.dateTime).getTime();
      const customKey = `${deviceId}_${inspectionTime}`;
      if (customDataMap[customKey]) {
        hubbometerValue = customDataMap[customKey];
        console.log(`Found Hubbometer value ${hubbometerValue} from custom field for ${deviceNames[deviceId]}`);
      }
      
      // 2. Try standard hubbometer field
      if (!hubbometerValue) {
        hubbometerValue = l.hubbometer || '';
      }
      
      // 3. Try to extract from remarks as fallback
      if (!hubbometerValue && l.driverRemark) {
        // Try to extract hubbometer from remarks with formats like:
        // "HUB: 12345" or "HUBBOMETER: 12345" or "Hub Odo: 12345"
        const hubMatch = l.driverRemark.match(/(?:HUB|HUBBOMETER|HUB ODO|HUBODO):\s*(\d+)/i);
        if (hubMatch) {
          hubbometerValue = hubMatch[1];
          console.log(`Extracted hubbometer ${hubbometerValue} from remarks for ${deviceNames[deviceId]}`);
        }
      }
      
      // Handle defects - try multiple sources
      let defectsString = '';
      let defectsArray = [];

      // First, try to get defects from the separately fetched defect map
      if (defectMap[l.id] && defectMap[l.id].length > 0) {
        defectsArray = defectMap[l.id];
        defectsString = JSON.stringify(defectsArray);
      }
      // Otherwise, try the defects field from the DVIR log itself
      else if (l.defects) {
        if (typeof l.defects === 'string') {
          defectsString = l.defects;
        } else if (Array.isArray(l.defects)) {
          defectsString = JSON.stringify(l.defects);
        } else if (typeof l.defects === 'object') {
          defectsString = JSON.stringify(l.defects);
        }
      }

      return {
        id:l.id,
        dateTime:new Date(l.dateTime).toLocaleString(),
        driverName:driverNames[driverId] || 'Unknown Driver',
        driverId:driverId || '',
        vehicleName:deviceNames[deviceId] || 'Unknown Vehicle',
        deviceId:deviceId || '',
        isSafeToOperate:l.isSafeToOperate,
        isInspectedByDriver:l.isInspectedByDriver,
        driverRemark:l.driverRemark || '',
        odometer:l.odometer || 0,
        engineHours:l.engineHours || 0,
        hubbometer:hubbometerValue,
        latitude:loc.latitude,
        longitude:loc.longitude,
        resolvedAddress:'',
        zones:[],
        defects:defectsString,
        isOverdue: false,
        ignitionTime: null,
        timeToInspection: null
      };
    });

    mappedDvirData = checkOverdueInspections(mappedDvirData);
    
    // Apply current filter before rendering
    const selectedZone = document.getElementById('zoneFilter').value;
    const filteredData = filterDataByZone(mappedDvirData, selectedZone);
    renderTable(filteredData);

    const locationsToResolve = mappedDvirData.filter(r => r.latitude != null && r.longitude != null);

    if (locationsToResolve.length > 0) {
      showMessage('infoBanner', `üåç Resolving ${locationsToResolve.length} addresses and matching zones...`, 'info');
      
      await resolveAllAddresses(mappedDvirData);
      
      renderZoneStatistics(mappedDvirData);
      
      const successCount = mappedDvirData.filter(r => r.resolvedAddress && r.resolvedAddress.trim()).length;
      const zoneCount = mappedDvirData.filter(r => r.zones && r.zones.length > 0).length;
      const hubbometerCount = mappedDvirData.filter(r => r.hubbometer && r.hubbometer.toString().trim()).length;
      const defectCount = mappedDvirData.filter(r => r.defects && r.defects !== '[]' && r.defects !== '').length;
      const failCount = locationsToResolve.length - successCount;

      if (successCount > 0) {
        showMessage('infoBanner', `‚úÖ SUCCESS! Addresses: ${successCount}/${locationsToResolve.length} | Zones: ${zoneCount}/${mappedDvirData.length} | Defects: ${defectCount}/${mappedDvirData.length} | Hubbometer: ${hubbometerCount}/${mappedDvirData.length}${failCount > 0 ? ` | ${failCount} addresses failed` : ''}`, 'success');
      } else {
        showMessage('infoBanner', `‚ö†Ô∏è Completed! Zones: ${zoneCount}/${mappedDvirData.length} | Defects: ${defectCount}/${mappedDvirData.length} | Hubbometer: ${hubbometerCount}/${mappedDvirData.length}`, 'warning');
      }
    } else {
      showMessage('infoBanner', '‚úÖ DVIR loaded! No locations to resolve.', 'success');
      renderZoneStatistics(mappedDvirData);
    }
    
    document.getElementById('downloadCsv').disabled = false;
    document.getElementById('downloadReport').disabled = false;

  }catch(e){
    showMessage('infoBanner', `Failed: ${e.message}`, 'error');
  }
};

document.getElementById('downloadCsv').onclick = function(){
  if(!mappedDvirData || mappedDvirData.length===0){ showMessage('infoBanner','No DVIR data to export','warning'); return; }
  
  // Log zone info before download
  const withZones = mappedDvirData.filter(r => r.zones && r.zones.length > 0).length;
  console.log(`Downloading CSV with ${mappedDvirData.length} inspections (${withZones} with zones, ${mappedDvirData.length - withZones} without zones)`);
  
  const headers = ['DateTime','Driver_Name','Vehicle_Name','Safe_To_Operate','Driver_Inspected','Has_Defects','Defect_Count','Defect_Details','Address','Zones','Latitude','Longitude','Odometer_km','Engine_Hours','Hubbometer','Ignition_Time','Time_To_Inspection_Min','Is_Overdue','Driver_Remarks'];
  let csv = headers.map(h=>`"${h}"`).join(',') + '\n';
  mappedDvirData.forEach(r=>{
    let hasDefects='NO', defectCount='0', defectDetails='';
    if (r.defects && r.defects !== '[]' && r.defects !== '') {
      try{
        const d = JSON.parse(r.defects);
        if(Array.isArray(d)&&d.length>0){
          hasDefects='YES';
          defectCount=String(d.length);
          defectDetails = d.map(def => {
            let defectName = '';
            // Check DefectRemarks array
            if (def.defectRemarks && Array.isArray(def.defectRemarks) && def.defectRemarks.length > 0) {
              defectName = def.defectRemarks[0].remark || def.defectRemarks[0].Remark || '';
            }
            // Check Defect object
            if (!defectName && def.defect && typeof def.defect === 'object') {
              defectName = def.defect.name || def.defect.Name || '';
            }
            // Check Part object
            if (!defectName && def.part && typeof def.part === 'object') {
              defectName = def.part.name || def.part.Name || '';
            }
            // Fallback
            if (!defectName) {
              defectName = def.name || def.Name || def.remark || def.Remark || 'Defect detected';
            }
            const repairStatus = def.repairStatus || def.RepairStatus || '';
            return `${defectName}${repairStatus ? ' [' + repairStatus + ']' : ''}`;
          }).join('; ');
        }
      }
      catch(e){
        console.error('Error parsing defects for CSV:', e, 'Raw defects:', r.defects);
        if(r.defects.length>10){ hasDefects='YES'; defectCount='Unknown'; defectDetails='Parse error'; }
      }
    }
    const zonesText = (r.zones||[]).join(' | ') || 'No Zone';
    const row = [
      r.dateTime, r.driverName, r.vehicleName,
      r.isSafeToOperate===true?'SAFE':r.isSafeToOperate===false?'UNSAFE':'UNKNOWN',
      r.isInspectedByDriver===true?'YES':'NO',
      hasDefects, defectCount, defectDetails,
      r.resolvedAddress || `${r.latitude || ''}, ${r.longitude || ''}`,
      zonesText,
      r.latitude || '', r.longitude || '',
      r.odometer ? Math.round(r.odometer/1000*100)/100 : '',
      r.engineHours ? Math.round(r.engineHours/3600*100)/100 : '',
      r.hubbometer || '',
      r.ignitionTime ? new Date(r.ignitionTime).toLocaleString() : '',
      r.timeToInspection || '',
      r.isOverdue ? 'YES' : 'NO',
      r.driverRemark || ''
    ].map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',');
    csv += row + '\n';
  });
  const ts = new Date().toISOString().slice(0,19).replace(/[:.]/g,'-');
  const filename = `Geotab_DVIR_With_Addresses_${ts}.csv`;
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = filename; a.style.display='none';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  showMessage('infoBanner', `üìä CSV "${filename}" downloaded with ${withZones} inspections containing zone data`, 'success');
};

document.getElementById('downloadReport').onclick = function(){
  if(!mappedDvirData || mappedDvirData.length===0){ showMessage('infoBanner','No DVIR data to report','warning'); return; }
  
  // Calculate zone statistics for the report
  const totalInspections = mappedDvirData.length;
  const withZones = mappedDvirData.filter(r => r.zones && r.zones.length > 0).length;
  const withoutZones = totalInspections - withZones;
  
  const zoneBreakdown = {};
  mappedDvirData.forEach(r => {
    if (r.zones && r.zones.length > 0) {
      r.zones.forEach(z => {
        zoneBreakdown[z] = (zoneBreakdown[z] || 0) + 1;
      });
    }
  });
  
  const zoneSummaryHtml = `
    <div style="background:#f8f9fa;padding:20px;margin:20px 0;border-radius:8px;border:2px solid #e2e8f0;">
      <h2 style="margin:0 0 15px 0;color:#2d3748;">Zone Distribution Summary</h2>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-bottom:15px;">
        <div style="background:white;padding:15px;border-radius:8px;text-align:center;">
          <div style="font-size:2em;font-weight:700;color:#667eea;">${totalInspections}</div>
          <div style="color:#666;font-size:0.9em;">Total Inspections</div>
        </div>
        <div style="background:white;padding:15px;border-radius:8px;text-align:center;">
          <div style="font-size:2em;font-weight:700;color:#48bb78;">${withZones}</div>
          <div style="color:#666;font-size:0.9em;">With Zones</div>
        </div>
        <div style="background:white;padding:15px;border-radius:8px;text-align:center;">
          <div style="font-size:2em;font-weight:700;color:#f56565;">${withoutZones}</div>
          <div style="color:#666;font-size:0.9em;">Without Zones</div>
        </div>
      </div>
      ${Object.keys(zoneBreakdown).length > 0 ? `
        <h3 style="margin:15px 0 10px 0;color:#2d3748;">Inspections per Zone:</h3>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:10px;">
          ${Object.entries(zoneBreakdown).sort((a,b) => b[1] - a[1]).map(([zone, count]) => `
            <div style="background:white;padding:10px 15px;border-radius:6px;display:flex;justify-content:space-between;align-items:center;">
              <span style="font-weight:600;">${zone}</span>
              <span style="background:#667eea;color:white;padding:4px 12px;border-radius:12px;font-weight:600;">${count}</span>
            </div>
          `).join('')}
        </div>
      ` : ''}
    </div>
  `;
  
  const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>DVIR Report (Working Addresses)</title>
  <style>
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:25px;color:#333;font-size:16px;line-height:1.5}
    h1{margin:0 0 8px 0;font-size:2.2em;color:#2d3748} .muted{color:#666;font-size:15px}
    table{width:100%;border-collapse:collapse;margin-top:20px}
    th,td{border:1px solid #e2e8f0;padding:12px;font-size:15px;text-align:left;vertical-align:top}
    th{background:#2c5aa0;color:#fff;font-weight:600}
    tr:nth-child(even){background:#f7fafc}
    .badge{padding:4px 8px;border-radius:4px;font-weight:700;font-size:13px;display:inline-block}
    .safe{background:#c6f6d5;color:#22543d}
    .unsafe{background:#fed7d7;color:#742a2a}
    .unknown{background:#e2e8f0;color:#4a5568}
    .overdue{background:#fefcbf;color:#744210}
    .real-address{background:#d4edda;color:#155724;padding:6px 8px;border-radius:4px;font-weight:500;border-left:4px solid #28a745}
    .coord-only{color:#666;font-style:italic}
    .zone-pill{display:inline-block;background:#e2e8f0;border-radius:999px;padding:2px 6px;margin:1px;font-size:11px;color:#495057}
    .ignition-info{font-size:12px;color:#666;margin-top:4px}
  </style></head><body>
  <h1>UCCL Asset Inspection Report</h1>
  <div class="muted">Generated on ${new Date().toLocaleString()}</div>
  ${zoneSummaryHtml}
  <table>
    <thead><tr>
      <th>Date/Time</th><th>Driver</th><th>Vehicle</th><th>Status</th><th>Driver Inspected</th>
      <th>Defects</th><th>Location</th><th>Zones</th><th>Odometer</th><th>Engine Hours</th><th>Hubbometer</th><th>Driver Remarks</th>
    </tr></thead>
    <tbody>${mappedDvirData.map(r=>{
      const status = r.isSafeToOperate===true?'<span class="badge safe">SAFE</span>':
                    r.isSafeToOperate===false?'<span class="badge unsafe">‚ö†Ô∏è UNSAFE</span>':
                    r.isOverdue?'<span class="badge overdue">‚è∞ OVERDUE</span>':
                    '<span class="badge unknown">UNKNOWN</span>';
      let defectDisplay = '<em class="muted">None</em>';
      if (r.defects && r.defects !== '[]' && r.defects !== '') {
        try{
          const d = JSON.parse(r.defects);
          if(Array.isArray(d)&&d.length>0) {
            const defectList = d.map(def => {
              let defectName = '';
              // Check DefectRemarks array
              if (def.defectRemarks && Array.isArray(def.defectRemarks) && def.defectRemarks.length > 0) {
                defectName = def.defectRemarks[0].remark || def.defectRemarks[0].Remark || '';
              }
              // Check Defect object
              if (!defectName && def.defect && typeof def.defect === 'object') {
                defectName = def.defect.name || def.defect.Name || '';
              }
              // Check Part object
              if (!defectName && def.part && typeof def.part === 'object') {
                defectName = def.part.name || def.part.Name || '';
              }
              // Fallback
              if (!defectName) {
                defectName = def.name || def.Name || def.remark || def.Remark || 'Defect detected';
              }
              const repairStatus = def.repairStatus || def.RepairStatus || '';
              return `${defectName}${repairStatus ? ' [' + repairStatus + ']' : ''}`;
            }).join(', ');
            defectDisplay = `<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è ${defectList}</span>`;
          }
        }
        catch(e){
          console.error('Error parsing defects:', e, 'Raw defects:', r.defects);
          if(r.defects.length>10) defectDisplay = '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Defects present</span>';
        }
      }
      let locationDisplay = '<em class="muted">No location</em>';
      if (r.latitude && r.longitude) {
        if (r.resolvedAddress && r.resolvedAddress.trim() && r.resolvedAddress.length > 8) {
          locationDisplay = `<div class="real-address">üìç ${r.resolvedAddress}</div>`;
        } else {
          const coords = `${Number(r.latitude).toFixed(6)}, ${Number(r.longitude).toFixed(6)}`;
          locationDisplay = `<span class="coord-only">${coords}</span>`;
        }
      }
      const zones = (r.zones||[]).map(z=>`<span class="zone-pill">${z}</span>`).join('') || '<em class="muted">No zone</em>';
      
      let ignitionInfo = '';
      if (r.ignitionTime) {
        const ignitionStr = new Date(r.ignitionTime).toLocaleString();
        const timeDiff = r.timeToInspection;
        ignitionInfo = `<div class="ignition-info">Ignition: ${ignitionStr} (${timeDiff}min before)</div>`;
      }
      
      return `<tr>
        <td>${r.dateTime}${ignitionInfo}</td>
        <td><strong>${r.driverName}</strong></td>
        <td><strong>${r.vehicleName}</strong></td>
        <td>${status}</td>
        <td>${r.isInspectedByDriver===true?'‚úÖ Yes':'‚ùå No'}</td>
        <td>${defectDisplay}</td>
        <td>${locationDisplay}</td>
        <td>${zones}</td>
        <td>${r.odometer?Math.round(r.odometer/1000*100)/100+' km':'N/A'}</td>
        <td>${r.engineHours?Math.round(r.engineHours/3600*100)/100+' hrs':'N/A'}</td>
        <td>${r.hubbometer ? `<strong style="color:#2d5016;">${r.hubbometer}</strong>` : '<span style="color:#e53e3e;font-weight:600;">‚ö†Ô∏è Missing</span>'}</td>
        <td>${r.driverRemark || '<em class="muted">No remarks</em>'}</td>
      </tr>`;
    }).join('')}</tbody>
  </table></body></html>`;
  const ts = new Date().toISOString().slice(0,19).replace(/[:.]/g,'-');
  const filename = `Geotab_DVIR_Report_${ts}.html`;
  const blob = new Blob([html], {type:'text/html;charset=utf-8;'});
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = filename; a.style.display='none';
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  showMessage('infoBanner', `üìÑ HTML Report "${filename}" downloaded with zone distribution summary (${withZones}/${totalInspections} inspections with zones)`, 'success');
};

document.getElementById('logout').onclick = function(){
  credentials = null;
  serverUsed = null;
  mappedDvirData = [];
  ignitionData = {};
  geotabZones = [];
  document.getElementById('dvirSection').style.display = 'none';
  document.getElementById('dvirResult').innerHTML = '';
  document.getElementById('authResult').innerHTML = '';
  document.getElementById('zoneStatistics').style.display = 'none';
  showMessage('authResult','Logged out','success');
};

// Event listeners
document.getElementById('enableAutoEmail').addEventListener('change', function() {
  document.getElementById('emailOptions').style.display = this.checked ? 'block' : 'none';
});

document.getElementById('zoneFilter').addEventListener('change', function() {
  if (!mappedDvirData.length) return;
  const selectedZone = this.value;
  const filteredData = filterDataByZone(mappedDvirData, selectedZone);
  renderTable(filteredData);
});

document.getElementById('alertWindow').addEventListener('change', function() {
  if (!mappedDvirData.length) return;
  mappedDvirData = checkOverdueInspections(mappedDvirData);
  const selectedZone = document.getElementById('zoneFilter').value;
  const filteredData = filterDataByZone(mappedDvirData, selectedZone);
  renderTable(filteredData);
});

document.getElementById('assetType').addEventListener('change', function() {
  if (!mappedDvirData.length) return;
  mappedDvirData = checkOverdueInspections(mappedDvirData);
  const selectedZone = document.getElementById('zoneFilter').value;
  const filteredData = filterDataByZone(mappedDvirData, selectedZone);
  renderTable(filteredData);
});

document.getElementById('enableOverdueAlerts').addEventListener('change', function() {
  if (!mappedDvirData.length) return;
  mappedDvirData = checkOverdueInspections(mappedDvirData);
  const selectedZone = document.getElementById('zoneFilter').value;
  const filteredData = filterDataByZone(mappedDvirData, selectedZone);
  renderTable(filteredData);
});

document.getElementById('groupByZone').addEventListener('change', function() {
  if (!mappedDvirData.length) return;
  const selectedZone = document.getElementById('zoneFilter').value;
  const filteredData = filterDataByZone(mappedDvirData, selectedZone);
  renderTable(filteredData);
});

// Simulate defect detection and auto-email
document.addEventListener('click', function(e) {
  if (e.target && e.target.classList.contains('status-unsafe')) {
    const row = e.target.closest('tr');
    const inspectionId = row ? row.getAttribute('data-inspection-id') : null;
    if (inspectionId) {
      const defectRow = mappedDvirData.find(r => r.id === inspectionId);
      if (defectRow) {
        sendDefectEmail(defectRow);
      }
    }
  }
});

if (window.geotab || window.api || (window.location && /geotab\.com/i.test(window.location.host))) {
  document.getElementById('dvirSection').style.display='';
  // Initialize zone dropdown with predefined zones on page load
  updateZoneDropdown();
}
</script>
</body>
</html>
